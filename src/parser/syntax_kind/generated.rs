//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub, clippy::upper_case_acronyms)]
#[doc = r" The kind of syntax node, e.g. `IDENTIFIER`, `RULE_KW`, or `AND`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    COLON,
    L_PAREN,
    R_PAREN,
    L_BRACE,
    R_BRACE,
    L_BRACKET,
    R_BRACKET,
    COMMA,
    ASSIGN,
    HYPHEN,
    QUESTION_MARK,
    TILDE,
    PIPE,
    SLASH,
    PLUS,
    STAR,
    PERCENTAGE,
    SHL,
    SHR,
    AMPERSAND,
    CARET,
    DOT,
    EQ,
    NE,
    LT,
    LE,
    GT,
    GE,
    AND_KW,
    OR_KW,
    NOT_KW,
    RULE_KW,
    STRINGS_KW,
    CONDITION_KW,
    META_KW,
    PRIVATE_KW,
    GLOBAL_KW,
    IMPORT_KW,
    INCLUDE_KW,
    ASCII_KW,
    WIDE_KW,
    NOCASE_KW,
    FULLWORD_KW,
    XOR_KW,
    BASE64_KW,
    BASE64WIDE_KW,
    CONTAINS_KW,
    ICONTAINS_KW,
    STARTSWITH_KW,
    ISTARTSWITH_KW,
    ENDSWITH_KW,
    IENDSWITH_KW,
    IEQUALS_KW,
    MATCHES_KW,
    STRING_LIT,
    INT_LIT,
    FLOAT_LIT,
    HEX_LIT,
    BOOL_LIT,
    REGEX_LIT,
    IDENTIFIER,
    VARIABLE,
    WHITESPACE,
    COMMENT,
    CASE_INSENSITIVE,
    DOT_MATCHES_ALL,
    ERROR,
    RULE,
    MODIFIER,
    TAG,
    STRINGS,
    META,
    CONDITION,
    SOURCE_FILE,
    BLOCK_EXPR,
    PREFIX_EXPR,
    EXPRESSION,
    EXPRESSION_STMT,
    VARIABLE_STMT,
    IMPORT_STMT,
    INCLUDE_STMT,
    META_STMT,
    PATTERN,
    PATTERN_MOD,
    BASE_ALPHABET,
    XOR_RANGE,
    HEX_PATTERN,
    HEX_TOKEN,
    HEX_TOKEN_TAIL,
    HEX_BYTE,
    HEX_ALTERNATIVE,
    HEX_JUMP,
    HEX_PIPE,
    REGEX_PATTERN,
    REGEX_MOD,
    BOOLEAN_TERM,
    BOOLEAN_EXPR,
    EXPR,
    TERM,
    PRIMARY_EXPR,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            AND_KW
                | OR_KW
                | NOT_KW
                | RULE_KW
                | STRINGS_KW
                | CONDITION_KW
                | META_KW
                | PRIVATE_KW
                | GLOBAL_KW
                | IMPORT_KW
                | INCLUDE_KW
                | ASCII_KW
                | WIDE_KW
                | NOCASE_KW
                | FULLWORD_KW
                | XOR_KW
                | BASE64_KW
                | BASE64WIDE_KW
                | CONTAINS_KW
                | ICONTAINS_KW
                | STARTSWITH_KW
                | ISTARTSWITH_KW
                | ENDSWITH_KW
                | IENDSWITH_KW
                | IEQUALS_KW
                | MATCHES_KW
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            COLON
                | L_PAREN
                | R_PAREN
                | L_BRACE
                | R_BRACE
                | L_BRACKET
                | R_BRACKET
                | COMMA
                | ASSIGN
                | HYPHEN
                | QUESTION_MARK
                | TILDE
                | PIPE
                | SLASH
                | PLUS
                | STAR
                | PERCENTAGE
                | SHL
                | SHR
                | AMPERSAND
                | CARET
                | DOT
                | EQ
                | NE
                | LT
                | LE
                | GT
                | GE
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(self, STRING_LIT | INT_LIT | FLOAT_LIT | HEX_LIT | BOOL_LIT | REGEX_LIT)
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "and" => AND_KW,
            "or" => OR_KW,
            "not" => NOT_KW,
            "rule" => RULE_KW,
            "strings" => STRINGS_KW,
            "condition" => CONDITION_KW,
            "meta" => META_KW,
            "private" => PRIVATE_KW,
            "global" => GLOBAL_KW,
            "import" => IMPORT_KW,
            "include" => INCLUDE_KW,
            "ascii" => ASCII_KW,
            "wide" => WIDE_KW,
            "nocase" => NOCASE_KW,
            "fullword" => FULLWORD_KW,
            "xor" => XOR_KW,
            "base64" => BASE64_KW,
            "base64wide" => BASE64WIDE_KW,
            "contains" => CONTAINS_KW,
            "icontains" => ICONTAINS_KW,
            "startswith" => STARTSWITH_KW,
            "istartswith" => ISTARTSWITH_KW,
            "endswith" => ENDSWITH_KW,
            "iendswith" => IENDSWITH_KW,
            "iequals" => IEQUALS_KW,
            "matches" => MATCHES_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ':' => COLON,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_BRACE,
            '}' => R_BRACE,
            '[' => L_BRACKET,
            ']' => R_BRACKET,
            ',' => COMMA,
            '=' => ASSIGN,
            '-' => HYPHEN,
            '?' => QUESTION_MARK,
            '~' => TILDE,
            '|' => PIPE,
            '/' => SLASH,
            '+' => PLUS,
            '*' => STAR,
            '%' => PERCENTAGE,
            '&' => AMPERSAND,
            '^' => CARET,
            '.' => DOT,
            '<' => LT,
            '>' => GT,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [:] => { $ crate :: SyntaxKind :: COLON } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_BRACE } ; ['}'] => { $ crate :: SyntaxKind :: R_BRACE } ; ['['] => { $ crate :: SyntaxKind :: L_BRACKET } ; [']'] => { $ crate :: SyntaxKind :: R_BRACKET } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; [=] => { $ crate :: SyntaxKind :: ASSIGN } ; [-] => { $ crate :: SyntaxKind :: HYPHEN } ; [?] => { $ crate :: SyntaxKind :: QUESTION_MARK } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [%] => { $ crate :: SyntaxKind :: PERCENTAGE } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [&] => { $ crate :: SyntaxKind :: AMPERSAND } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [==] => { $ crate :: SyntaxKind :: EQ } ; [!=] => { $ crate :: SyntaxKind :: NE } ; [<] => { $ crate :: SyntaxKind :: LT } ; [<=] => { $ crate :: SyntaxKind :: LE } ; [>] => { $ crate :: SyntaxKind :: GT } ; [>=] => { $ crate :: SyntaxKind :: GE } ; [and] => { $ crate :: SyntaxKind :: AND_KW } ; [or] => { $ crate :: SyntaxKind :: OR_KW } ; [not] => { $ crate :: SyntaxKind :: NOT_KW } ; [rule] => { $ crate :: SyntaxKind :: RULE_KW } ; [strings] => { $ crate :: SyntaxKind :: STRINGS_KW } ; [condition] => { $ crate :: SyntaxKind :: CONDITION_KW } ; [meta] => { $ crate :: SyntaxKind :: META_KW } ; [private] => { $ crate :: SyntaxKind :: PRIVATE_KW } ; [global] => { $ crate :: SyntaxKind :: GLOBAL_KW } ; [import] => { $ crate :: SyntaxKind :: IMPORT_KW } ; [include] => { $ crate :: SyntaxKind :: INCLUDE_KW } ; [ascii] => { $ crate :: SyntaxKind :: ASCII_KW } ; [wide] => { $ crate :: SyntaxKind :: WIDE_KW } ; [nocase] => { $ crate :: SyntaxKind :: NOCASE_KW } ; [fullword] => { $ crate :: SyntaxKind :: FULLWORD_KW } ; [xor] => { $ crate :: SyntaxKind :: XOR_KW } ; [base64] => { $ crate :: SyntaxKind :: BASE64_KW } ; [base64wide] => { $ crate :: SyntaxKind :: BASE64WIDE_KW } ; [contains] => { $ crate :: SyntaxKind :: CONTAINS_KW } ; [icontains] => { $ crate :: SyntaxKind :: ICONTAINS_KW } ; [startswith] => { $ crate :: SyntaxKind :: STARTSWITH_KW } ; [istartswith] => { $ crate :: SyntaxKind :: ISTARTSWITH_KW } ; [endswith] => { $ crate :: SyntaxKind :: ENDSWITH_KW } ; [iendswith] => { $ crate :: SyntaxKind :: IENDSWITH_KW } ; [iequals] => { $ crate :: SyntaxKind :: IEQUALS_KW } ; [matches] => { $ crate :: SyntaxKind :: MATCHES_KW } ; [identifier] => { $ crate :: SyntaxKind :: IDENTIFIER } ; [variable] => { $ crate :: SyntaxKind :: VARIABLE } ; [string_lit] => { $ crate :: SyntaxKind :: STRING_LIT } ; [int_lit] => { $ crate :: SyntaxKind :: INT_LIT } ; [float_lit] => { $ crate :: SyntaxKind :: FLOAT_LIT } ; [bool_lit] => { $ crate :: SyntaxKind :: BOOL_LIT } ; [hex_lit] => { $ crate :: SyntaxKind :: HEX_LIT } ; [regex_lit] => { $ crate :: SyntaxKind :: REGEX_LIT } ; [dot_matches_all] => { $ crate :: SyntaxKind :: DOT_MATCHES_ALL } ; [case_insensitive] => { $ crate :: SyntaxKind :: CASE_INSENSITIVE } ; }
pub use T;
